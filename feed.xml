<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://eugeniomoro.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://eugeniomoro.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-30T19:46:16+00:00</updated><id>https://eugeniomoro.github.io/feed.xml</id><title type="html">blank</title><subtitle>Here&apos;s my academic webpage. </subtitle><entry><title type="html">Experimenting with GSM Full Rate and Half Rate Voice Codec</title><link href="https://eugeniomoro.github.io/blog/2025/gsm-voice-codec/" rel="alternate" type="text/html" title="Experimenting with GSM Full Rate and Half Rate Voice Codec"/><published>2025-03-22T14:55:00+00:00</published><updated>2025-03-22T14:55:00+00:00</updated><id>https://eugeniomoro.github.io/blog/2025/gsm-voice-codec</id><content type="html" xml:base="https://eugeniomoro.github.io/blog/2025/gsm-voice-codec/"><![CDATA[<p>A few days ago, while teaching how GSM works to my students, I reached the part where I explained GSM voice codecs. I shared how there’s more than one codec—specifically, the Full Rate codec, which operates at around 13 kbps, and the Half Rate codec, which works at roughly 5.5 kbps.</p> <p>As far as I know, the Half Rate codec was (or perhaps I should say <em>is</em>) almost never used. This got me thinking: why? After all, Half Rate theoretically allows the system to support twice the number of calls. It must be because of the quality loss, right?</p> <p>But how bad could the quality really be to outweigh the benefit of doubling the system’s capacity? And if the quality was that poor, why even offer the option in the first place? I decided to dig deeper and test it myself.</p> <p>I started by recording my voice and then went online to look for GSM voice codec software. At first, I wasn’t very hopeful, as it seemed like an obscure task. But to my surprise, it turned out to be easier than I thought.</p> <p><a href="https://www.videolan.org/vlc/">VLC</a> can reproduce GSM-encoded voice (is there anything VLC can’t do?). And <a href="https://ffmpeg.org">FFmpeg</a> comes with built-in GSM encoding and decoding capabilities. This made me wonder: why do these tools support GSM codecs out-of-the-box? Is there a significant need for people to work with GSM voice codecs? Perhaps it’s related to GSM eavesdropping? But let’s not go down that rabbit hole.</p> <p>Back to our task, here’s how you do it. Let’s assume that we have an audio file, call it <code class="language-plaintext highlighter-rouge">voice.wav</code>. You will have to instruct <code class="language-plaintext highlighter-rouge">ffmpeg</code> to downsample it to 4 kHz, downmix the stereo into mono, encode it using <code class="language-plaintext highlighter-rouge">gsm</code> and save it in a new file called <code class="language-plaintext highlighter-rouge">voice.gsm</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffmpeg -i voice.wav -ar 8000 -ac 1 -g gsm voice.gsm
</code></pre></div></div> <p>Then open the file with VLC and there you go: you’re listening to your voice coded with the GSM voice codec. Thanks for your attention, see you at the next post.</p> <p>No, wait a second. I didn’t specify Full Rate/Half Rate. I recorded around 13 seconds of voice, and got a gsm file of around 176 kB. That gives me a bitrate of 13.5 kbps. <code class="language-plaintext highlighter-rouge">ffmpeg</code> is using Full Rate! But, as I said, I want to use half rate, I want to experience how bad it is.</p> <p>I searched some more, it seems that <code class="language-plaintext highlighter-rouge">libgsm</code> (the codec library used by <code class="language-plaintext highlighter-rouge">ffmpeg</code>) only supports full rate. I couldn’t use <code class="language-plaintext highlighter-rouge">ffmpeg</code> for this. But then I found <a href="https://osmocom.org/projects/gapk/wiki">GAPK</a>, a collection of GSM codecs packed into a command line tool, part of the awesome Osmocom project. <code class="language-plaintext highlighter-rouge">GAPK</code> supports Half Rate, but we have to install it first. Unfortunately there’s no documentation, but the tool is simple enough that we can figure out how it works while using it.</p> <p>We must start with the dependencies. This has been tested on ubuntu 22.04.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt install build-essential libtool libtalloc-dev libsctp-dev shtool autoconf automake git-core pkg-config make gcc gnutls-dev python2-minimal libusb-1.0.0-dev libmnl-dev liburing-dev libpcsclite-dev
</code></pre></div></div> <p>Now we need to clone and build <code class="language-plaintext highlighter-rouge">libosmocore</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://gitea.osmocom.org/osmocom/libosmocore.git
cd libosmocore/
autoreconf -i
./configure
make -j $(nproc)
sudo make install
sudo ldconfig -i
cd ..
</code></pre></div></div> <p>Finally we can move to installing <code class="language-plaintext highlighter-rouge">GAPK</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://gitea.osmocom.org/osmocom/gapk
cd gapk/
autoreconf -i
./configure --enable-gsmhr
make -j $(nproc)
sudo make install
sudo ldconfig
</code></pre></div></div> <p>If you get an error that says that some headers were not found during <code class="language-plaintext highlighter-rouge">make</code>, just run <code class="language-plaintext highlighter-rouge">make</code> again. That fixed it for me.</p> <p>Now test if everything went fine with <code class="language-plaintext highlighter-rouge">osmo-gapk -h</code>.</p> <p><code class="language-plaintext highlighter-rouge">GAPK</code> can encode <code class="language-plaintext highlighter-rouge">Raw PCM samples Signed 16 bits little endian</code> into different GSM formats, and viceversa. Unfortunately, there’s approximately a 0% probability that your original voice file is a raw PCM file. So we have to prepare it with <code class="language-plaintext highlighter-rouge">ffmpeg</code> first:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffmpeg -i voice.wav -f s16le -acodec pcm_s16le -ar 8000 -ac 1 voice.pcm
</code></pre></div></div> <p>That gives us a <code class="language-plaintext highlighter-rouge">voice.pcm</code> file that can be processed by <code class="language-plaintext highlighter-rouge">GAPK</code>. Let’s encode it using Half Rate:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>osmo-gapk -i voice.pcm -f rawpcm-s16le -g racal-hr -o voice.hr
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">voice.hr</code> is 72.8 kbytes, giving us a bitrate of 5.6 kbps—exactly what we were expecting!</p> <p>Unfortunately VLC can’t reproduce Half Rate files. We have to decode it back into PCM using <code class="language-plaintext highlighter-rouge">GAPK</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>osmo-gapk -i voice.hr -f racal-hr -g rawpcm-s16le -o voice.hr.pcm
</code></pre></div></div> <p>and then into a VLC-supported format with <code class="language-plaintext highlighter-rouge">ffmpeg</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffmpeg -f s16le -ar 8000 -ac 1 -i voice.hr.pcm voice.hr.wav
</code></pre></div></div> <p>Finally we can reproduce <code class="language-plaintext highlighter-rouge">voice.hr.wav</code>, which contains the uncompressed audio of our voice, which was previously encoded using Half Rate.</p> <p>And the quality is… good? Really? At least it is from my macbook’s speakers.</p> <p>All of this didn’t prove my theory, but it was a fun way to spend half an hour!</p>]]></content><author><name></name></author><category term="experiments"/><category term="GSM"/><category term="Experiments"/><summary type="html"><![CDATA[A few days ago, while teaching how GSM works to my students, I reached the part where I explained GSM voice codecs. I shared how there’s more than one codec—specifically, the Full Rate codec, which operates at around 13 kbps, and the Half Rate codec, which works at roughly 5.5 kbps.]]></summary></entry><entry><title type="html">Planning radio networks, can you do better than my students?</title><link href="https://eugeniomoro.github.io/blog/2025/planning-notebook/" rel="alternate" type="text/html" title="Planning radio networks, can you do better than my students?"/><published>2025-03-01T12:57:00+00:00</published><updated>2025-03-01T12:57:00+00:00</updated><id>https://eugeniomoro.github.io/blog/2025/planning-notebook</id><content type="html" xml:base="https://eugeniomoro.github.io/blog/2025/planning-notebook/"><![CDATA[<p>In the context of mobile radio networks, radio planning means finding the optimal number and position of base stations to be installed in a given area. The optimality is evaluated against particular network objectives. The simplest objective one can imagine is to maximize the coverage in the given area, whatever that means, while being constrained to a monetary budget.</p> <p>Wireless networks are expensive both to deploy and operate. That’s why radio planning is essential for operators. With a good network plan, they can get the most out of their often limited budget.</p> <p>I learned about radio planning during my M.Sc., but I kind of ignored it at that time. I discovered the beauty of it only during my first year of PhD when I finally started working on it practically.</p> <p>I wanted to bring the same experience to my students, so I wrote this jupyter notebook, where I guide them through a very simple network planning instance. Most of the code is used to prepare the data, namely the positions of base stations and users, as well as the propagation data.</p> <p>When the data is ready, one can finally solve the planning. That’s easier said than done, as usual. Even the simplest planning we can imagine (like this one) is NP-Hard. Fortunately, a network plan can take hours or days to solve since it’s an operation done once in a long while.</p> <p>We couldn’t leave the lecture without seeing a solution, and I also wanted to give my students a little improvised challenge. So I wrote a pretty bad heuristic algorithm and left them 30 minutes to modify it. Whoever could modify it to increase the performance (in terms of increased coverage) would pass the challenge and get half a point. I also gave 1 point to the best-performing heuristic.</p> <p>I prepared a form where they could upload their solution, with a backend that evaluated each submission and updated a live leaderboard that I projected in the class during the challenge. When solutions started to come up on the leaderboard, I felt a mixture of satisfaction and relief; it was working! Not only did my students understand what network planning means, but they also found ways to improve my solution.</p> <p>After 30 minutes, 22 out of 28 participants could pass the challenge. Two of them who got the highest score managed to get a solution that was only 2 % worse than the optimal. I was pretty impressed.</p> <p>That challenge is close now, but that doesn’t mean you can’t still try. Can you do better than my students? You’ll find the jupyter notebook here on this page. If not, you will still learn something about radio planning.</p> <div class="jupyter-notebook" style="position: relative; width: 100%; margin: 0 auto;"> <div class="jupyter-notebook-iframe-container"> <iframe src="/assets/jupyter/MRN_25_Radio_channel_and_planning_primer.ipynb.html" style="position: absolute; top: 0; left: 0; border-style: none;" width="100%" height="100%" onload="this.parentElement.style.paddingBottom = (this.contentWindow.document.documentElement.scrollHeight + 10) + 'px'"></iframe> </div> </div>]]></content><author><name></name></author><category term="teaching"/><category term="planning"/><category term="jupyter"/><category term="MRN"/><summary type="html"><![CDATA[Follow through this basic radio planning notebook, and see if you can do better than my students.]]></summary></entry></feed>